package kb_RAST::kb_RASTImpl;
use strict;

#BEGIN_HEADER
#
use Bio::KBase::AuthToken;
use Bio::KBase::GenomeAnnotation::GenomeAnnotationImpl;

use Config::IniFiles;

use installed_clients::KBaseReportClient;


#END_HEADER

#BEGIN_CONSTRUCTOR
sub new
{
    my($class, @args) = @_;
    my $self = {};
    bless $self, $class;

    #BEGIN_CONSTRUCTOR--automatically generated by kb-sdk init
    my $config_file = $ENV{ KB_DEPLOYMENT_CONFIG };
    my $cfg = Config::IniFiles->new(-file=>$config_file);
    my $scratch = $cfg->val('kb_RAST', 'scratch');
    my $callbackURL = $ENV{ SDK_CALLBACK_URL };

    $self->{scratch} = $scratch;
    $self->{callbackURL} = $callbackURL;
    #END_CONSTRUCTOR--automatically generated by kb-sdk init

	Bio::KBase::Utilities::read_config({
        service => "RAST_SDK",
        mandatory => ['workspace-url', 'relation-engine-url']
	});
	$self->{_re_url} = Bio::KBase::Utilities::conf(
        $ENV{KB_SERVICE_NAME} or "RAST_SDK", "relation-engine-url");
	# TODO check url is ok by querying RE root

    if ($self->can('_init_instance'))
    {
        $self->_init_instance();
    }
    return $self;
}
#END_CONSTRUCTOR

#BEGIN run_rast_workflow
sub run_rast_workflow
{
    my ($self, $in_genome, $workflow) = @_;

    my $count = scalar @{$in_genome->{features}};
    print "******INFO: Run RAST pipeline on $in_genome->{id} with $count features.******\n";

    my $rasted_gn = $in_genome;
    my $g_data_type = (ref($rasted_gn) eq 'HASH') ? 'ref2Hash' : ref($rasted_gn);
    if ($g_data_type eq 'GenomeTypeObject') {
        print "**********Genome input passed to the run_rast_workflow with:\n".Dumper($workflow)." is of type of $g_data_type, prepare it**********.\n";
        $rasted_gn = $rasted_gn->prepare_for_return();
    }

    eval {
        my $rast_client = Bio::KBase::GenomeAnnotation::GenomeAnnotationImpl->new();
        $rasted_gn = $rast_client->run_pipeline($rasted_gn, $workflow);
    };
    if ($@) {
        print "********ERROR calling rast run_pipeline with\n".Dumper($workflow)."\non $in_genome->{id}:\n$@\n";
    }
    else {
        print "********SUCCEEDED: calling rast run_pipeline with\n".Dumper($workflow)."\non $in_genome->{id}.\n";
    }
    return $rasted_gn;
}
#END run_rast_workflow


#BEGIN rast_annotate_ama
sub rast_annotate_ama
{
    my ($self, $inputgenome) = @_;
    my $count = scalar @{$inputgenome->{features}};
    print "******Run RAST pipeline on genome with $count features.******\n";
    print "For example, first 3 features: \n".Dumper(@{$inputgenome->{features}}[0..2]);

    my $rasted_gn = {};
    eval {
	#my $rast_client = installed_clients::GenomeAnnotationClient->new($self->{call_back_url});
	my $rast_client = Bio::KBase::GenomeAnnotation::GenomeAnnotationImpl->new();
        $rasted_gn = $rast_client->run_pipeline($inputgenome,
            {stages => [{name => "annotate_proteins_kmer_v2",
                         kmer_v2_parameters => {min_hits => "5",
			                        dataset_name => "V2Data",
                                                annotate_hypothetical_only => 0}},
                        {name => "annotate_proteins_kmer_v1",
                         kmer_v1_parameters => {dataset_name => "Release70",
                                                annotate_hypothetical_only => 0}}]}
        );
    };
    if ($@) {
        croak "ERROR calling rast run_pipeline: ".$@."\n";
    }
    return $rasted_gn;

}
#END rast_annotate_ama

#BEGIN_STATUS
    $return = {"state" => "OK", "message" => "", "version" => $VERSION, "git_url" => $GIT_URL, "git_commit_hash" => $GIT_COMMIT_HASH};
#END_STATUS
