package kb_RAST::kb_RASTImpl;
use strict;

our $VERSION = '0.0.1';
our $GIT_URL = 'https://github.com/kbaseapps/kb_RAST.git';
our $GIT_COMMIT_HASH = '';


#BEGIN_HEADER
#
use Bio::KBase::AuthToken;
use Bio::KBase::Utilities;
use Bio::KBase::KBaseEnv;
use Bio::KBase::GenomeAnnotation::GenomeAnnotationImpl;
use Bio::KBase::GenomeAnnotation::Service;

use Config::IniFiles;

use GenomeTypeObject;

#END_HEADER

#BEGIN run_rast_workflow
sub run_rast_workflow
{
    my ($self, $in_genome, $workflow) = @_;

    my $count = scalar @{$in_genome->{features}};
    print "******INFO: Run RAST pipeline on $in_genome->{id} with $count features.******\n";

    my $rasted_gn = $in_genome;
    my $g_data_type = (ref($rasted_gn) eq 'HASH') ? 'ref2Hash' : ref($rasted_gn);
    if ($g_data_type eq 'GenomeTypeObject') {
        print "**********Genome input passed to the run_rast_workflow with:\n".Dumper($workflow)." is of type of $g_data_type, prepare it**********.\n";
        $rasted_gn = $rasted_gn->prepare_for_return();
    }

    eval {
        my $rast_client = Bio::KBase::GenomeAnnotation::GenomeAnnotationImpl->new();
        $rasted_gn = $rast_client->run_pipeline($rasted_gn, $workflow);
    };
    if ($@) {
        print "********ERROR calling rast run_pipeline with\n".Dumper($workflow)."\non $in_genome->{id}:\n$@\n";
    }
    else {
        print "********SUCCEEDED: calling rast run_pipeline with\n".Dumper($workflow)."\non $in_genome->{id}.\n";
    }
    return $rasted_gn;
}
#END run_rast_workflow

#BEGIN rast_annotate_ama
sub rast_annotate_ama
{
    my ($self, $inputgenome) = @_;
    my $count = scalar @{$inputgenome->{features}};
    print "******Run RAST pipeline on genome with $count features.******\n";
    print "For example, first 3 features: \n".Dumper(@{$inputgenome->{features}}[0..2]);

    my $rasted_gn = {};
    my $ama_anno_wf = {
        stages => [
            {name => "annotate_proteins_kmer_v2",
             kmer_v2_parameters => {min_hits => "5",
                                    dataset_name => "V2Data",
                                    annotate_hypothetical_only => 0}
            },
            {name => "annotate_proteins_kmer_v1",
             kmer_v1_parameters => {dataset_name => "Release70",
                                    annotate_hypothetical_only => 0}
            }]
    };

    eval {
        #my $rast_client = installed_clients::GenomeAnnotationClient->new($self->{call_back_url});
        my $rast_client = Bio::KBase::GenomeAnnotation::GenomeAnnotationImpl->new();
        $rasted_gn = $rast_client->run_pipeline($inputgenome, $ama_anno_wf);
    };
    if ($@) {
        croak "ERROR calling rast run_pipeline: ".$@."\n";
    }
    return $rasted_gn;
}

#END rast_annotate_ama


#BEGIN_CONSTRUCTOR
sub new
{
    my($class, @args) = @_;
    my $self = {};
    bless $self, $class;

    #BEGIN_CONSTRUCTOR--automatically generated by kb-sdk init
    my $config_file = $ENV{ KB_DEPLOYMENT_CONFIG };
    my $cfg = Config::IniFiles->new(-file=>$config_file);
    my $scratch = $cfg->val('kb_RAST', 'scratch');
    my $callbackURL = $ENV{ SDK_CALLBACK_URL };

    $self->{scratch} = $scratch;
    $self->{callbackURL} = $callbackURL;
    #END_CONSTRUCTOR--automatically generated by kb-sdk init

    if ($self->can('_init_instance'))
    {
        $self->_init_instance();
    }
    return $self;
}
#END_CONSTRUCTOR

#
## Initialize the instance
#
sub _init_instance {
    my $self = shift;

    $self->{ctx} = $kb_RAST::kb_RASTServer::CallContext;
    $self->{_token} = $self->{ctx}->token();
    $self->{_username} = $self->{ctx}->user_id();
    $self->{_provenance} = $self->{ctx}->provenance();

    $self->{ws_url} = $self->{config}->{'workspace-url'};

    die "no workspace-url defined" unless $self->{ws_url};

    $self->{ws_client} = installed_clients::WorkspaceClient->new(
                             $self->{ws_url}, token => $self->{_token});

    return 1;
}

#
## status - Return the module status. This is a structure including Semantic Versioning number,
## state and git info.
#
sub status {
    my($return);
    #BEGIN_STATUS
    $return = {"state" => "OK", "message" => "", "version" => $VERSION,
               "git_url" => $GIT_URL, "git_commit_hash" => $GIT_COMMIT_HASH};
    #END_STATUS
    return($return);
}
